use std::iter::Peekable;

use crate::utils::random_access_container::RandomAccessContainer;

use super::{
    action_buffer::ActorId,
    field_data::{FieldValueRepr, RunLength},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum FieldActionKind {
    #[default]
    Dup,
    Drop,
    /// Inserts a header for zero sized data at the specified field
    /// position, pushing any existing header at that position forwards.
    /// Iterators are also pushed forwards, unless they have the
    /// `lean_left_on_insert` property set.
    InsertZst {
        repr: FieldValueRepr,
        actor_id: ActorId,
    },
}

/// In lists of `FieldAction`s, the indices assume that all previous actions
/// were applied.
///
/// Consecutive field actions of the same kind and with the same index have
/// the same semantics as a single action with the summed run length.
/// Field actions with a run length greater than `RunLength::MAX` can
/// therefore be represented by multiple, consecutive field actions on the
/// same index. Typically, all `FieldAction`s in such a chain but the last one
/// will have the maximum possible run length. This is *the* way to encode any
/// action with a run length greater than `RunLength::MAX`. Even for inserts,
/// where another represnetation would be possible:
/// Insert(0, `RunLength::MAX`) + Insert(`RunLength::MAX`, `RunLength::MAX`),
/// we prefer Insert(0, `RunLength::MAX`) + Insert(0, `RunLength::MAX`). The
/// u32 instead of usize for `RunLength` should be thought of as nothing but an
/// optimization that gets reverted at the lowest layer possible.
///
///
/// `FieldAction`s Lists shall maintain the following invariants:
/// - All action `run_length`s must be greater than 0
///
/// - Each index in a list must be at least as large as the previous.
///
/// - `Dup`s may not refer to records that were inserted or generated by a
///   previous dup. (Therefore, two consecutive `Dup`s must either refer to the
///   same starting index, or the second one must point *after* the last index
///   occupied by results of the first `Dup`).
///
/// - `Drop`s may not refer to records that were inserted or dup'ed into
///   existance by this action list. E.g.: `[Dup{idx: 0, rl: 3}, Drop{idx: 2,
///   rl: 3}]` is illegal. It should be expressed as `[Dup{idx: 0, rl: 1},
///   Drop{idx: 2, rl: 1}]`
///
/// Violating these invariants may lead to unexpected behavior, panics or
/// infinite loops. Memory safety shall be maintained though.
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct FieldAction {
    pub kind: FieldActionKind,
    pub field_idx: usize,
    pub run_len: RunLength,
}

#[derive(Clone, Copy)]
struct FieldActionFullRl {
    kind: FieldActionKind,
    field_idx: usize,
    run_len: usize,
}

#[allow(unused)]
pub struct PendingAction {
    kind: FieldActionKind,
    start: usize,
    committed_rl: usize,
    outstanding_rl: usize,
}

impl FieldAction {
    pub fn new(
        kind: FieldActionKind,
        field_idx: usize,
        run_len: RunLength,
    ) -> Self {
        Self {
            kind,
            field_idx,
            run_len,
        }
    }
}

impl FieldActionKind {
    pub fn to_str(&self) -> &'static str {
        match self {
            FieldActionKind::Dup => "Dup",
            FieldActionKind::Drop => "Drop",
            FieldActionKind::InsertZst { repr, actor_id: _ } => match repr {
                FieldValueRepr::Undefined => "Insert(Undefined)",
                FieldValueRepr::Null => "Insert(Null)",
                _ => {
                    unreachable!("InsertZst only supports null and undefined")
                }
            },
        }
    }
}

impl From<FieldAction> for FieldActionFullRl {
    fn from(fa: FieldAction) -> Self {
        FieldActionFullRl {
            kind: fa.kind,
            field_idx: fa.field_idx,
            run_len: fa.run_len as usize,
        }
    }
}

struct ActionMergeData<'a, L, R, T>
where
    L: Iterator<Item = FieldAction>,
    R: Iterator<Item = FieldAction>,
    T: RandomAccessContainer<FieldAction>,
{
    left: Peekable<L>,
    right: Peekable<R>,
    target: &'a mut T,
    pending_actions: &'a mut Vec<PendingAction>,
    field_pos_offset_left: i64,
    outstanding_drops_right: usize,
    pending_actions_train_end: usize,
    last_committed_action: Option<FieldActionFullRl>,
}

impl<'a, L, R, T> ActionMergeData<'a, L, R, T>
where
    L: Iterator<Item = FieldAction>,
    R: Iterator<Item = FieldAction>,
    T: RandomAccessContainer<FieldAction>,
{
    fn release_action(&mut self, mut faf: FieldActionFullRl) {
        let mut action = FieldAction {
            kind: faf.kind,
            field_idx: faf.field_idx,
            run_len: 0,
        };
        while faf.run_len > RunLength::MAX as usize {
            action.run_len = RunLength::MAX;
            self.target.push(action);
            faf.run_len -= RunLength::MAX as usize;
        }
        if faf.run_len > 0 {
            action.run_len = faf.run_len as RunLength;
            self.target.push(action);
        }
    }

    fn commit_action(&mut self, mut action: FieldActionFullRl) {
        if action.run_len == 0 {
            return;
        }

        let Some(mut prev) = self.last_committed_action else {
            self.last_committed_action = Some(action);
            return;
        };
        let prev_end = prev.field_idx + prev.run_len;
        let overlapping_inclusive = action.field_idx <= prev_end;
        let overlapping_exclusive = action.field_idx < prev_end;
        let same_idx = action.field_idx == prev.field_idx;

        let mut add = false;
        let mut subtract = false;
        let mut subtract_inclusive = false;
        use FieldActionKind;
        match (prev.kind, action.kind) {
            (FieldActionKind::Dup, FieldActionKind::Dup) => {
                add = overlapping_inclusive;
            }
            (FieldActionKind::Dup, FieldActionKind::Drop) => {
                subtract = overlapping_inclusive;
                subtract_inclusive = true;
            }
            (FieldActionKind::Drop, FieldActionKind::Drop) => {
                add = same_idx;
            }
            (FieldActionKind::InsertZst { .. }, FieldActionKind::Dup) => {
                if overlapping_exclusive {
                    add = true;
                    action.kind = prev.kind;
                }
            }
            (FieldActionKind::InsertZst { .. }, FieldActionKind::Drop) => {
                subtract = overlapping_exclusive;
            }
            (
                FieldActionKind::InsertZst { .. },
                FieldActionKind::InsertZst { .. },
            ) => {
                let same_kind = prev.kind == action.kind;
                add = overlapping_exclusive && same_kind;
            }
            (
                FieldActionKind::Drop,
                FieldActionKind::Dup | FieldActionKind::InsertZst { .. },
            )
            | (FieldActionKind::Dup, FieldActionKind::InsertZst { .. }) => (),
        }
        debug_assert!(!add || !subtract);

        if add {
            let space_rem =
                (RunLength::MAX as usize - prev.run_len).min(action.run_len);
            prev.run_len += space_rem;
            action.run_len -= space_rem;
        }
        if subtract {
            // inclusive:
            // [Dup(0, 2), Drop(1, 2)] -> []
            // exclusive:
            // [Insert(0, 2), Drop(1,2)] -> [Insert(0, 1), Drop(1, 1)]
            let overlap = (prev_end + usize::from(subtract_inclusive)
                - action.field_idx)
                .min(action.run_len);

            prev.run_len -= overlap;
            action.run_len -= overlap;
        }
        if action.run_len == 0 {
            self.last_committed_action = Some(prev);
            return;
        }
        self.release_action(prev);
        self.last_committed_action = Some(action);
    }

    fn commit_pending_actions(&mut self) {
        if self.pending_actions.is_empty() {
            return;
        }
        for i in 0..self.pending_actions.len() {
            let a = &self.pending_actions[i];
            self.commit_action(FieldActionFullRl {
                kind: a.kind,
                field_idx: a.start,
                run_len: a.committed_rl + a.outstanding_rl,
            });
        }
        self.pending_actions.clear()
    }

    fn commit_pending_action_parts_before_pos(&mut self, mut pos: usize) {
        for pa in self.pending_actions.iter_mut().rev() {
            let to_commit = (pos - pa.start).min(pa.outstanding_rl);
            pa.committed_rl += to_commit;
            pa.outstanding_rl -= to_commit;
            pos -= pa.committed_rl;
        }
    }

    fn apply_drop_to_pending_actions(
        &mut self,
        drop_pos: usize,
        drop_count: usize,
    ) -> usize {
        self.commit_pending_action_parts_before_pos(drop_pos);
        let mut drops_rem = drop_count;
        for pa in self.pending_actions.iter_mut().rev() {
            let drops = pa.outstanding_rl.min(drops_rem);
            pa.outstanding_rl -= drops;
            drops_rem -= drops;
            if drops_rem == 0 {
                break;
            }
        }

        let drops_applied = drop_count - drops_rem;
        self.pending_actions_train_end -= drops_applied;

        debug_assert!(self.pending_actions_train_end >= drop_pos);
        if self.pending_actions_train_end == drop_pos {
            self.commit_pending_actions();
        }

        drops_applied
    }

    fn push_pending_action(&mut self, action: PendingAction) {
        self.commit_pending_action_parts_before_pos(action.start);
        let action_end =
            action.start + action.committed_rl + action.outstanding_rl;
        if self.pending_actions_train_end == usize::MAX {
            self.pending_actions_train_end = action_end;
        } else {
            self.pending_actions_train_end =
                self.pending_actions_train_end.max(action_end);
        }
        self.pending_actions.push(action);
    }

    fn consume_left_action(&mut self) {
        let action_left = self.left.next().unwrap();

        let pending_actions = !self.pending_actions.is_empty();

        let mut faf = FieldActionFullRl {
            field_idx: (action_left.field_idx as i64
                + self.field_pos_offset_left) as usize,
            run_len: action_left.run_len as usize,
            kind: action_left.kind,
        };

        match action_left.kind {
            FieldActionKind::InsertZst { .. } | FieldActionKind::Dup => {
                let next_right = self.next_action_index_right();
                let mut next_left = self.next_action_index_left();

                let mut next_action = next_left.min(next_right);

                let mut space_to_next = next_action - faf.field_idx;

                let drop_by = self
                    .outstanding_drops_right
                    .min(faf.run_len)
                    .min(space_to_next);

                if drop_by > 0 {
                    faf.run_len -= drop_by;
                    self.outstanding_drops_right -= drop_by;
                    self.field_pos_offset_left -= drop_by as i64;
                    next_left -= drop_by;
                    next_action = next_left.min(next_right);
                    space_to_next = next_action - faf.field_idx;
                }

                if faf.run_len == 0 {
                    let mut available_drop = self
                        .outstanding_drops_right
                        .saturating_sub(space_to_next);
                    if available_drop > 0 {
                        if pending_actions {
                            available_drop -= self
                                .apply_drop_to_pending_actions(
                                    faf.field_idx,
                                    available_drop,
                                );
                        }
                        if available_drop > 0 {
                            faf.kind = FieldActionKind::Drop;
                            faf.run_len = available_drop;
                            self.commit_action(faf);
                            self.outstanding_drops_right -= available_drop;
                        }
                    }
                    return;
                }

                let action_end = faf.field_idx + faf.run_len;

                let pending_actions_end_including_this = if pending_actions {
                    self.pending_actions_train_end.max(action_end)
                } else {
                    action_end
                };

                if pending_actions_end_including_this > next_action {
                    self.commit_pending_action_parts_before_pos(faf.field_idx);
                    let committed_rl = faf.run_len.min(space_to_next);
                    self.push_pending_action(PendingAction {
                        kind: faf.kind,
                        start: faf.field_idx,
                        committed_rl,
                        outstanding_rl: faf.run_len - committed_rl,
                    });
                    return;
                }
                if pending_actions {
                    self.commit_pending_actions();
                }

                let space_to_next_left = next_left - faf.field_idx;

                if self.outstanding_drops_right <= space_to_next_left {
                    if self.outstanding_drops_right >= faf.run_len {
                        self.outstanding_drops_right -= faf.run_len;
                        faf.kind = FieldActionKind::Drop;
                        faf.run_len = self.outstanding_drops_right;
                        self.commit_action(faf);
                        return;
                    }
                    faf.run_len -= self.outstanding_drops_right;
                    self.outstanding_drops_right = 0;
                    self.commit_action(faf);
                    return;
                }
                debug_assert!(!pending_actions);
                let dup_to_undo = faf.run_len;
                self.outstanding_drops_right -= dup_to_undo;
                self.field_pos_offset_left -= dup_to_undo as i64;

                let drop_due =
                    self.outstanding_drops_right.min(space_to_next_left);

                faf.run_len = drop_due;
                self.outstanding_drops_right -= drop_due;
                self.field_pos_offset_left -= drop_due as i64;
                faf.kind = FieldActionKind::Drop;
                self.commit_action(faf);
            }
            FieldActionKind::Drop => {
                if pending_actions {
                    debug_assert!(
                        self.pending_actions_train_end
                            <= self.outstanding_drops_right
                    );
                    self.commit_pending_actions();
                }
                if self.outstanding_drops_right == 0 {
                    self.commit_action(faf);
                    return;
                }
                // if there previously was a right drop that we haven't
                // fully honored yet, we add as much of that drop as
                // we can to ourselves.
                let consume_from_right = if let Some(next) = self.left.peek() {
                    // the next element on the left might cancel
                    // out parts of the right drop, so we can only
                    // commit the uncontested parts
                    let gap_to_next_left =
                        next.field_idx - action_left.field_idx;
                    gap_to_next_left.min(self.outstanding_drops_right)
                } else {
                    self.outstanding_drops_right
                };
                faf.run_len += consume_from_right;
                self.outstanding_drops_right -= consume_from_right;
                self.field_pos_offset_left -= consume_from_right as i64;
                self.commit_action(faf);
            }
        }
    }

    fn consume_right_action(&mut self) {
        let mut action = FieldActionFullRl::from(self.right.next().unwrap());

        let pending_actions = !self.pending_actions.is_empty();

        debug_assert!(
            !pending_actions
                || self.pending_actions_train_end > action.field_idx
        );

        match action.kind {
            FieldActionKind::InsertZst { .. } | FieldActionKind::Dup => {
                self.field_pos_offset_left += action.run_len as i64;
                if !pending_actions {
                    self.commit_action(action);
                    return;
                }
                self.push_pending_action(PendingAction {
                    kind: action.kind,
                    start: action.field_idx,
                    committed_rl: action.run_len,
                    outstanding_rl: 0,
                });
            }
            FieldActionKind::Drop => {
                if pending_actions {
                    action.run_len -= self.apply_drop_to_pending_actions(
                        action.field_idx,
                        action.run_len,
                    );
                }
                let gap_to_start_left =
                    self.next_action_index_left() - action.field_idx;
                if gap_to_start_left < action.run_len {
                    self.outstanding_drops_right +=
                        action.run_len - gap_to_start_left;
                    action.run_len = gap_to_start_left;
                }
                self.field_pos_offset_left -= action.run_len as i64;
                self.commit_action(action);
            }
        }
    }

    fn run(&mut self) {
        while let Some(action_left) = self.left.peek().copied() {
            let action_right = self.right.peek().copied();

            let next_left = self.next_action_index_left();
            let next_right = self.next_action_index_right();

            let mut consume_left = next_left <= next_right;

            if next_left == next_right {
                consume_left =
                    match (action_left.kind, action_right.map(|a| a.kind)) {
                        (FieldActionKind::Drop, _) => true,
                        (
                            _,
                            Some(
                                FieldActionKind::Drop
                                | FieldActionKind::InsertZst { .. },
                            ),
                        ) => false,
                        (_, _) => true,
                    };
            }
            if consume_left {
                self.consume_left_action();
                continue;
            }
            self.consume_right_action();
        }
        while self.right.peek().is_some() {
            self.consume_right_action();
        }
        self.commit_pending_actions();

        if let Some(a) = self.last_committed_action {
            self.release_action(a);
        }
    }

    fn next_action_index_left(&mut self) -> usize {
        self.left
            .peek()
            .map(|a| {
                (a.field_idx as i64 + self.field_pos_offset_left) as usize
            })
            .unwrap_or(usize::MAX)
    }
    fn next_action_index_right(&mut self) -> usize {
        self.right.peek().map(|a| a.field_idx).unwrap_or(usize::MAX)
    }

    fn new(
        left: Peekable<L>,
        right: Peekable<R>,
        target: &'a mut T,
        pending_actions: &'a mut Vec<PendingAction>,
    ) -> Self {
        debug_assert!(pending_actions.is_empty());

        Self {
            left,
            right,
            target,
            pending_actions,
            field_pos_offset_left: 0,
            outstanding_drops_right: 0,
            pending_actions_train_end: usize::MAX,
            last_committed_action: None,
        }
    }
}

pub fn merge_action_lists<'a>(
    left: impl IntoIterator<Item = &'a FieldAction>,
    right: impl IntoIterator<Item = &'a FieldAction>,
    pending_actions: &mut Vec<PendingAction>,
    target: &mut impl RandomAccessContainer<FieldAction>,
) {
    let left = left.into_iter().copied().peekable();
    let right = right.into_iter().copied().peekable();

    ActionMergeData::new(left, right, target, pending_actions).run();
}

#[cfg(test)]
mod test {
    use crate::{
        record_data::{action_buffer::ActorId, field_data::FieldValueRepr},
        utils::indexing_type::IndexingType,
    };

    use super::FieldActionKind;

    use super::FieldAction;
    use rstest::rstest;
    const INSERT_UNDEF: FieldActionKind = FieldActionKind::InsertZst {
        repr: FieldValueRepr::Undefined,
        actor_id: ActorId::ZERO,
    };

    #[track_caller]
    fn compare_merge_result(
        left: &[FieldAction],
        right: &[FieldAction],
        out: &[FieldAction],
    ) {
        let mut output = Vec::new();
        let mut pending_actions = Vec::new();
        super::merge_action_lists(
            left,
            right,
            &mut pending_actions,
            &mut output,
        );
        assert_eq!(output.as_slice(), out);
    }
    #[test]
    fn uncontested_drops_survive_merge() {
        let drops = &[
            FieldAction::new(FieldActionKind::Drop, 0, 2),
            FieldAction::new(FieldActionKind::Drop, 1, 9),
            FieldAction::new(FieldActionKind::Drop, 2, 7),
        ];
        compare_merge_result(drops, &[], drops);
        compare_merge_result(&[], drops, drops);
    }

    #[rstest]
    #[case(FieldActionKind::Dup)]
    #[case(FieldActionKind::Drop)]
    fn actions_are_merged(#[case] kind: FieldActionKind) {
        let unmerged = &[
            FieldAction {
                kind,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind,
                field_idx: 0,
                run_len: 1,
            },
        ];
        let blank = &[];
        let merged = &[FieldAction {
            kind,
            field_idx: 0,
            run_len: 2,
        }];
        compare_merge_result(unmerged, blank, merged);
        compare_merge_result(blank, unmerged, merged);
    }

    #[test]
    fn dup_inside_previous_dup() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   a   a  | a   a   a  |
        // 1 | b   a   a   a   a  | b   a   a  |
        // 2 | c   a   a   a   a  | c   a   a  |
        // 3 |     b   b   a   a  |     a   a  |
        // 4 |     c   b   a   a  |     a   a  |
        // 5 |         c   b   a  |     a   a  |
        // 6 |             b   b  |     b   b  |
        // 7 |             c   b  |     c   b  |
        // 8 |                 c  |         c  |
        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn dup_inside_previous_dup_2() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   a   a  | a   a   a  |
        // 1 | b   a   a   a   a  | b   a   a  |
        // 2 | c   b   b   a   a  | c   a   a  |
        // 3 |     c   b   b   a  |     a   a  |
        // 4 |         c   b   b  |     b   b  |
        // 5 |             c   b  |     c   b  |
        // 6 |                 c  |         c  |
        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 3,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 4,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn left_field_indices_are_adjusted() {
        let left = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn basic_inserts_test() {
        let left = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_come_before_dups() {
        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 1,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_can_be_duplicated() {
        let left = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 2,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_can_be_duplicated_2() {
        let left = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 2,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 4,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 2,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 4,
                run_len: 1,
            },
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 6,
                run_len: 2,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert() {
        let left = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert_2() {
        // Before:  Left:    Right
        //    0       0        0
        //    1       GS       1
        //    2       1        2
        //            GS
        //            2

        let left = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert_3() {
        // Before:  Left:    Right
        //    0       0        0
        //    1       GS       1
        //    2       GS       2
        //            1
        //            GS
        //            2

        let left = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 1,
                run_len: 2,
            },
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 4,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn encompassed_dups_are_deleted() {
        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 4,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn interrupted_left_actions() {
        //  # | BF  L1  L2  R1  R2 | BF  M1  M2  M3 |
        //  0 | a   a   a   e   e  | a   e   e   e  |
        //  1 | b   a   a   f   f  | b   f   f   f  |
        //  2 | c   b   b   g   i  | c   g   i   i  |
        //  3 | d   c   c   h   i  | d   h   j   i  |
        //  4 | e   d   d   i   j  | e   i       j  |
        //  5 | f   e   e   i      | f   j          |
        //  6 | g   f   f   j      | g              |
        //  7 | h   g   g          | h              |
        //  8 | i   h   h          | i              |
        // 10 | j   i   i          | j              |
        // 11 |     j   i          |                |
        // 12 |         j          |                |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 10,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 3,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 4,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn interrupted_left_actions_2() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   b   b  | a   b   b  |
        // 1 | b   b   b   c   c  | b   c   c  |
        // 2 | c   b   b   d   f  | c   d   f  |
        // 3 | d   c   c   e   g  | d   e   g  |
        // 4 | e   d   d   f      | e   f      |
        // 5 | f   e   e   f      | f   g      |
        // 6 | g   f   f   g      | g          |
        // 7 |     g   f          |            |
        // 8 |         g          |            |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 3,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 2,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn chained_right_drops() {
        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 10,
            run_len: 1,
        }];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 8,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn overlapping_drops() {
        let a = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 3,
            run_len: 5,
        }];
        let b = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 2,
            run_len: 3,
        }];
        let merged_a_b = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 2,
            run_len: 8,
        }];
        let merged_b_a = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 3,
                run_len: 5,
            },
        ];
        compare_merge_result(a, b, merged_a_b);
        compare_merge_result(b, a, merged_b_a);
    }

    #[test]
    fn drop_inside_dup() {
        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 3,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let merged = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 2,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_deletes_dup() {
        // # | BF  L   R  |
        // 0 | a   a   a  |
        // 1 | b   a   b  |
        // 2 |     a      |
        // 3 |     b      |

        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 2,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 2,
        }];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_erasing_multiple_dups() {
        // # | BF  L1  L2  L3  R  | BF M |
        // 0 | a   a   a   a   a  | a  a |
        // 1 | b   b   b   b   e  | b  e |
        // 2 | c   b   b   b      | c    |
        // 3 | d   c   c   c      | d    |
        // 4 | e   d   c   c      | e    |
        // 5 |     e   d   d      |      |
        // 6 |         e   d      |      |
        // 7 |             e      |      |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 3,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 5,
                run_len: 1,
            },
        ];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 6,
        }];
        let merged = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 3,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn multiple_drops_reduce_dup() {
        // # | BF  L   R1 R2 | BF M |
        // 0 | a   a   a  a  | a  a |
        // 1 | b   a   a  a  | b  a |
        // 2 |     a   a  b  |    b |
        // 3 |     a   b     |      |
        // 4 |     b         |      |

        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 3,
        }];
        let right = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_doesnt_delete_insert() {
        // # | BF  L   R   | BF  M1  M2 |
        // 0 | a   x   x   | a   x   x  |
        // 1 | b   x   b   | b   a   b  |
        // 2 |     a       |     b      |
        // 3 |     b       |            |

        let left = &[FieldAction {
            kind: INSERT_UNDEF,
            field_idx: 0,
            run_len: 2,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 1,
            run_len: 2,
        }];
        let merged = &[
            FieldAction {
                kind: INSERT_UNDEF,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drops_are_combined() {
        // # | BF  L1  L2  L3  R  | BF  M |
        // 0 | a   c   c   c      | a     |
        // 1 | b   d   e   e      | b     |
        // 2 | c   e   f   g      | c     |
        // 3 | d   f   g          | d     |
        // 4 | e   g              | e     |
        // 5 | f                  | f     |
        // 5 | g                  | g     |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FieldActionKind::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 3,
        }];
        let merged = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 7,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn insert_into_dup() {
        // # | BF  L  R   | BF  M1  M2 |
        // 0 | a   a  a   | a   a   a  |
        // 1 |     a  _   |     a   _  |
        // 2 |     a  _   |     a   _  |
        // 3 |        _   |         _  |
        // 4 |        _   |         _  |
        // 5 |        a   |         a  |
        // 5 |        a   |         a  |

        let left = &[FieldAction {
            kind: FieldActionKind::Dup,
            run_len: 2,
            field_idx: 0,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::InsertZst {
                repr: FieldValueRepr::Undefined,
                actor_id: ActorId::one(),
            },
            run_len: 4,
            field_idx: 1,
        }];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                run_len: 2,
                field_idx: 0,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Undefined,
                    actor_id: ActorId::one(),
                },
                run_len: 4,
                field_idx: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn intersecting_inserts() {
        // you might think that we would want this:
        // # | BF  L  R  | BF  M1  M2  M3 |
        // 0 | a   a  a  | a   a   a   a  |
        // 1 | b   x  x  | b   x   x   x  |
        // 2 |     x  y  |     b   y   y  |
        // 3 |     x  y  |         y   y  |
        // 4 |     b  y  |         y   y  |
        // 5 |        x  |         b   x  |
        // 6 |        x  |             x  |
        // 7 |        b  |             b  |
        // but unfortunately that is not (necessarily) equivalent with respect
        // to iterator adjustments, so we keep the intersecting inserts
        // instead:
        // # | BF  L  R  | BF  M1  M2 |
        // 0 | a   a  a  | a   a   a  |
        // 1 | b   x  x  | b   x   x  |
        // 2 |     x  y  |     x   y  |
        // 3 |     x  y  |     x   y  |
        // 4 |     b  y  |     b   y  |
        // 5 |        x  |         x  |
        // 6 |        x  |         x  |
        // 7 |        b  |         b  |

        let left = &[FieldAction {
            kind: FieldActionKind::InsertZst {
                repr: FieldValueRepr::Undefined,
                actor_id: ActorId::ZERO,
            },
            field_idx: 1,
            run_len: 3,
        }];
        let right = &[FieldAction {
            kind: FieldActionKind::InsertZst {
                repr: FieldValueRepr::Null,
                actor_id: ActorId::ZERO,
            },
            field_idx: 2,
            run_len: 3,
        }];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Undefined,
                    actor_id: ActorId::ZERO,
                },
                field_idx: 1,
                run_len: 3,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Null,
                    actor_id: ActorId::ZERO,
                },
                field_idx: 2,
                run_len: 3,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_inside_dup_remain_untouched() {
        // we can't split inserts like so, because that would mess with iter
        // adjustments:
        // # | BF L1  L2  R1  | BF  M1  M2  M3  M4 |
        // 0 | a  a   a   a   | a   a   a   a   a  |
        // 1 |    a   x   x   |     a   x   x   x  |
        // 2 |    a   x   y   |     a   a   y   y  |
        // 3 |        x   y   |         a   y   y  |
        // 4 |        a   y   |             y   y  |
        // 5 |        a   x   |             a   x  |
        // 6 |            x   |             a   x  |
        // 7 |            a   |                 a  |
        // 8 |            a   |                 a  |
        // so we just keep it as is:
        // # | BF L1  L2  R1  | BF  M1  M2  M3 |
        // 0 | a  a   a   a   | a   a   a   a  |
        // 1 |    a   x   x   |     a   x   x  |
        // 2 |    a   x   y   |     a   x   y  |
        // 3 |        x   y   |         x   y  |
        // 4 |        a   y   |         a   y  |
        // 5 |        a   x   |         a   x  |
        // 6 |            x   |             x  |
        // 7 |            a   |             a  |
        // 8 |            a   |             a  |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Undefined,
                    actor_id: ActorId::ZERO,
                },
                field_idx: 1,
                run_len: 3,
            },
        ];
        let right = &[FieldAction {
            kind: FieldActionKind::InsertZst {
                repr: FieldValueRepr::Null,
                actor_id: ActorId::ZERO,
            },
            field_idx: 2,
            run_len: 3,
        }];
        let merged = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Undefined,
                    actor_id: ActorId::ZERO,
                },
                field_idx: 1,
                run_len: 3,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Null,
                    actor_id: ActorId::ZERO,
                },
                field_idx: 2,
                run_len: 3,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn dup_and_insert_into_drop() {
        // # | BF  L1  L2  R  | BF  M |
        // 0 | a   a   a   a  | a   a |
        // 1 |     a   _   a  |     a |
        // 2 |     a   _      |       |
        // 3 |         _      |       |
        // 4 |         _      |       |
        // 5 |         a      |       |
        // 5 |         a      |       |

        let left = &[
            FieldAction {
                kind: FieldActionKind::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FieldActionKind::InsertZst {
                    repr: FieldValueRepr::Undefined,
                    actor_id: ActorId::one(),
                },
                field_idx: 1,
                run_len: 4,
            },
        ];
        let right = &[FieldAction {
            kind: FieldActionKind::Drop,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[FieldAction {
            kind: FieldActionKind::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        compare_merge_result(left, right, merged);
    }
}
