use std::{
    collections::VecDeque,
    ops::{Index, IndexMut},
};

use super::field_data::{FieldValueRepr, RunLength};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum FieldActionKind {
    #[default]
    Dup,
    Drop,
    /// Inserts a header for zero sized data at the specified field
    /// position, pushing any existing header at that position forwards.
    /// Iterators are also pushed forwards, unless they have the
    /// `lean_left_on_insert` property set.
    InsertZst(FieldValueRepr),
}

/// In lists of `FieldAction`s, the indices assume that all previous actions
/// were applied.
///
/// Consecutive field actions of the same kind and with the same index have
/// the same semantics as a single action with the summed run length.
///
/// Field actions with a run length greater than `RunLength::MAX` can
/// therefore be represented by multiple, consecutive field actions on the
/// same index. Typically, all `FieldAction`s in such a chain but the last one
/// will have the maximum possible run length.
///
/// `FieldAction`s Lists shall maintain the following invariants:
/// - All action `run_length`s must be greater than 0
///
/// - Each index in a list must be at least as large as the previous.
///
/// - `Insert`s shall not refer to indexes that were `Dup`ed on before.
///
/// - Indices may **not** refer to fields that were generated by previous
///   actions.
///
///   E.g.: `[Dup{idx: 0, rl: 3}, Drop{idx: 2, rl: 3}]` is illegal.
///   It should be expressed as `[Dup{idx: 0, rl: 1}, Drop{idx: 2, rl: 1}]`.
///
///   Similarily, two consecutive `Dup`s must either refer to the same
///   starting index, or the second one must point *after* the last index
///   occupied by results of the first `Dup`.
///
/// Violating these invariants may lead to unexpected behavior, panics or
/// infinite loops. Memory safety shall be maintained though.
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct FieldAction {
    pub kind: FieldActionKind,
    pub field_idx: usize,
    pub run_len: RunLength,
}

#[derive(Clone, Copy)]
struct FieldActionFullRl {
    kind: FieldActionKind,
    field_idx: usize,
    run_len: usize,
}

impl FieldAction {
    pub fn new(
        kind: FieldActionKind,
        field_idx: usize,
        run_len: RunLength,
    ) -> Self {
        Self {
            kind,
            field_idx,
            run_len,
        }
    }
}

impl From<FieldAction> for FieldActionFullRl {
    fn from(fa: FieldAction) -> Self {
        FieldActionFullRl {
            kind: fa.kind,
            field_idx: fa.field_idx,
            run_len: fa.run_len as usize,
        }
    }
}

pub trait ActionContainer:
    Index<usize, Output = FieldAction> + IndexMut<usize, Output = FieldAction>
{
    fn get(&self, index: usize) -> Option<&FieldAction>;
    fn last_mut(&mut self) -> Option<&mut FieldAction>;
    fn push(&mut self, v: FieldAction);
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

impl ActionContainer for Vec<FieldAction> {
    fn get(&self, index: usize) -> Option<&FieldAction> {
        <[FieldAction]>::get(self, index)
    }
    fn last_mut(&mut self) -> Option<&mut FieldAction> {
        <[FieldAction]>::last_mut(self)
    }
    fn push(&mut self, v: FieldAction) {
        <Vec<_>>::push(self, v)
    }
    fn len(&self) -> usize {
        <[FieldAction]>::len(self)
    }
}
impl ActionContainer for VecDeque<FieldAction> {
    fn get(&self, index: usize) -> Option<&FieldAction> {
        <VecDeque<_>>::get(self, index)
    }
    fn last_mut(&mut self) -> Option<&mut FieldAction> {
        self.back_mut()
    }
    fn push(&mut self, v: FieldAction) {
        <VecDeque<_>>::push_back(self, v)
    }
    fn len(&self) -> usize {
        <VecDeque<_>>::len(self)
    }
}

fn push_merged_action_raw<T: ActionContainer>(
    target: &mut T,
    mut faf: FieldActionFullRl,
) {
    let mut action = FieldAction {
        kind: faf.kind,
        field_idx: faf.field_idx,
        run_len: 0,
    };
    while faf.run_len > RunLength::MAX as usize {
        action.run_len = RunLength::MAX;
        target.push(action);
        faf.run_len -= RunLength::MAX as usize;
    }
    if faf.run_len > 0 {
        action.run_len = faf.run_len as RunLength;
        target.push(action);
    }
}

fn push_merged_action<T: ActionContainer>(
    target: &mut T,
    prev_opt: &mut Option<FieldActionFullRl>,
    mut curr: FieldActionFullRl,
) {
    if curr.run_len == 0 {
        return;
    }

    let Some(mut prev) = *prev_opt else {
        *prev_opt = Some(curr);
        return;
    };
    let prev_end = prev.field_idx + prev.run_len;
    let overlapping_inclusive = curr.field_idx <= prev_end;
    let overlapping_exclusive = curr.field_idx < prev_end;
    let same_idx = curr.field_idx == prev.field_idx;

    let mut add = false;
    let mut subtract = false;
    let mut subtract_inclusive = false;
    use FieldActionKind as FAK;
    match (prev.kind, curr.kind) {
        (FAK::Dup, FAK::Dup) => {
            add = overlapping_inclusive;
        }
        (FAK::Dup, FAK::Drop) => {
            subtract = overlapping_inclusive;
            subtract_inclusive = true;
        }
        (FAK::Drop, FAK::Drop) => {
            add = same_idx;
        }
        (FAK::InsertZst(_), FAK::Dup) => {
            if overlapping_exclusive {
                add = true;
                curr.kind = prev.kind;
            }
        }
        (FAK::InsertZst(_), FAK::Drop) => {
            subtract = overlapping_exclusive;
        }
        (FAK::InsertZst(a), FAK::InsertZst(b)) => {
            debug_assert!(a == b);
            add = overlapping_exclusive;
        }
        (FAK::Drop, FAK::Dup | FAK::InsertZst(_))
        | (FAK::Dup, FAK::InsertZst(_)) => (),
    }
    debug_assert!(!add || !subtract);

    if add {
        let space_rem =
            (RunLength::MAX as usize - prev.run_len).min(curr.run_len);
        prev.run_len += space_rem;
        curr.run_len -= space_rem;
    }
    if subtract {
        // inclusive:
        // [Dup(0, 2), Drop(1, 2)] -> []
        // exclusive:
        // [Insert(0, 2), Drop(1,2)] -> [Insert(0, 1), Drop(1, 1)]
        let overlap = (prev_end + usize::from(subtract_inclusive)
            - curr.field_idx)
            .min(curr.run_len);

        prev.run_len -= overlap;
        curr.run_len -= overlap;
    }
    if curr.run_len == 0 {
        *prev_opt = Some(prev);
        return;
    }
    push_merged_action_raw(target, prev);
    *prev_opt = Some(curr);
}

pub fn merge_action_lists_inner<'a>(
    left: impl Iterator<Item = &'a FieldAction>,
    right: impl Iterator<Item = &'a FieldAction>,
    target: &mut impl ActionContainer,
) {
    let mut left = left.copied().peekable();
    let mut right = right.copied().peekable();

    let mut prev_action = None;

    let mut next_action_field_idx_left;
    let mut next_action_field_idx_right;
    let mut field_pos_offset_left: isize = 0;
    let mut outstanding_drops_right: usize = 0;
    while let Some(action_left) = left.peek().copied() {
        let action_right = right.peek().copied();
        if let Some(action_right) = action_right {
            next_action_field_idx_right = action_right.field_idx;
        } else {
            next_action_field_idx_right = usize::MAX;
        }
        next_action_field_idx_left =
            (action_left.field_idx as isize + field_pos_offset_left) as usize;

        let mut consume_left =
            next_action_field_idx_left <= next_action_field_idx_right;

        if next_action_field_idx_left == next_action_field_idx_right {
            consume_left =
                match (action_left.kind, action_right.map(|a| a.kind)) {
                    (FieldActionKind::Drop, _) => true,
                    (
                        _,
                        Some(
                            FieldActionKind::Drop
                            | FieldActionKind::InsertZst(_),
                        ),
                    ) => false,
                    (_, _) => true,
                };
        }

        if consume_left {
            left.next();
            let mut faf = FieldActionFullRl {
                field_idx: (action_left.field_idx as isize
                    + field_pos_offset_left)
                    as usize,
                run_len: action_left.run_len as usize,
                kind: action_left.kind,
            };

            match action_left.kind {
                FieldActionKind::InsertZst(_) | FieldActionKind::Dup => {
                    if outstanding_drops_right >= faf.run_len {
                        let dup_to_undo = faf.run_len;
                        outstanding_drops_right -= dup_to_undo;
                        field_pos_offset_left -= dup_to_undo as isize;

                        let drop_due: usize = if let Some(next) = left.peek() {
                            let next_pos = next.field_idx as isize
                                + field_pos_offset_left;
                            outstanding_drops_right
                                .min(next_pos as usize - faf.field_idx)
                        } else {
                            outstanding_drops_right
                        };

                        faf.run_len = drop_due;
                        outstanding_drops_right -= drop_due;
                        field_pos_offset_left -= drop_due as isize;
                        faf.kind = FieldActionKind::Drop;
                    } else {
                        faf.run_len -= outstanding_drops_right;
                        outstanding_drops_right = 0;
                    }
                }
                FieldActionKind::Drop => {
                    if outstanding_drops_right > 0 {
                        let consume_from_right =
                            if let Some(next) = left.peek() {
                                let gap_to_next_left =
                                    next.field_idx - action_left.field_idx;
                                gap_to_next_left.min(outstanding_drops_right)
                            } else {
                                outstanding_drops_right
                            };
                        faf.run_len += consume_from_right;
                        outstanding_drops_right -= consume_from_right;
                        field_pos_offset_left -= consume_from_right as isize;
                    }
                }
            }
            push_merged_action(target, &mut prev_action, faf);
            continue;
        }

        let mut faf = FieldActionFullRl::from(right.next().unwrap());

        match faf.kind {
            FieldActionKind::InsertZst(_) | FieldActionKind::Dup => {
                field_pos_offset_left += faf.run_len as isize;
            }
            FieldActionKind::Drop => {
                let gap_to_start_left =
                    next_action_field_idx_left - next_action_field_idx_right;
                if gap_to_start_left < faf.run_len {
                    outstanding_drops_right += faf.run_len - gap_to_start_left;
                    faf.run_len = gap_to_start_left;
                }
                field_pos_offset_left -= faf.run_len as isize;
            }
        }
        push_merged_action(target, &mut prev_action, faf);
    }
    debug_assert_eq!(outstanding_drops_right, 0);
    for action in right {
        push_merged_action(target, &mut prev_action, action.into());
    }
    if let Some(prev) = prev_action {
        push_merged_action_raw(target, prev);
    }
}

pub fn merge_action_lists<'a>(
    left: impl IntoIterator<Item = &'a FieldAction>,
    right: impl IntoIterator<Item = &'a FieldAction>,
    target: &mut impl ActionContainer,
) {
    // NOTE(cmrs, 2024-06-18): rust-analyzer currently has problems with
    // typechecking `IntoIterator`s (#17257), so we isolate the meat of this
    // algorithm from that problem through this indirection
    merge_action_lists_inner(left.into_iter(), right.into_iter(), target)
}

#[cfg(test)]
mod test {
    use crate::record_data::field_data::FieldValueRepr;

    use super::FieldActionKind;

    use super::FieldAction;
    use FieldActionKind as FAK;

    #[track_caller]
    fn compare_merge_result(
        left: &[FieldAction],
        right: &[FieldAction],
        out: &[FieldAction],
    ) {
        let mut output = Vec::new();
        super::merge_action_lists(left, right, &mut output);
        assert_eq!(output.as_slice(), out);
    }
    #[test]
    fn uncontested_drops_survive_merge() {
        let drops = &[
            FieldAction::new(FAK::Drop, 0, 2),
            FieldAction::new(FAK::Drop, 1, 9),
            FieldAction::new(FAK::Drop, 2, 7),
        ];
        compare_merge_result(drops, &[], drops);
        compare_merge_result(&[], drops, drops);
    }

    #[test]
    fn actions_are_merged() {
        for kind in [FAK::Dup, FAK::Drop] {
            let unmerged = &[
                FieldAction {
                    kind,
                    field_idx: 0,
                    run_len: 1,
                },
                FieldAction {
                    kind,
                    field_idx: 0,
                    run_len: 1,
                },
            ];
            let blank = &[];
            let merged = &[FieldAction {
                kind,
                field_idx: 0,
                run_len: 2,
            }];
            compare_merge_result(unmerged, blank, merged);
            compare_merge_result(blank, unmerged, merged);
        }
    }

    #[test]
    fn dup_inside_previous_dup() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   a   a  | a   a   a  |
        // 1 | b   a   a   a   a  | b   a   a  |
        // 2 | c   a   a   a   a  | c   a   a  |
        // 3 |     b   b   a   a  |     a   a  |
        // 4 |     c   b   a   a  |     a   a  |
        // 5 |         c   b   a  |     a   a  |
        // 6 |             b   b  |     b   b  |
        // 7 |             c   b  |     c   b  |
        // 8 |                 c  |         c  |
        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 3,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn dup_inside_previous_dup_2() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   a   a  | a   a   a  |
        // 1 | b   a   a   a   a  | b   a   a  |
        // 2 | c   b   b   a   a  | c   a   a  |
        // 3 |     c   b   b   a  |     a   a  |
        // 4 |         c   b   b  |     b   b  |
        // 5 |             c   b  |     c   b  |
        // 6 |                 c  |         c  |
        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 3,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 4,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn left_field_indices_are_adjusted() {
        let left = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn basic_inserts_test() {
        let left = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_come_before_dups() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 1,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_can_be_duplicated() {
        let left = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 2,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn inserts_can_be_duplicated_2() {
        let left = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 2,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 4,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 2,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 4,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 6,
                run_len: 2,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert() {
        let left = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 1,
        }];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert_2() {
        // Before:  Left:    Right
        //    0       0        0
        //    1       GS       1
        //    2       1        2
        //            GS
        //            2

        let left = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 3,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_cancels_insert_3() {
        // Before:  Left:    Right
        //    0       0        0
        //    1       GS       1
        //    2       GS       2
        //            1
        //            GS
        //            2

        let left = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 1,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 4,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn encompassed_dups_are_deleted() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 4,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn interrupted_left_actions() {
        //  # | BF  L1  L2  R1  R2 | BF  M1  M2  M3 |
        //  0 | a   a   a   e   e  | a   e   e   e  |
        //  1 | b   a   a   f   f  | b   f   f   f  |
        //  2 | c   b   b   g   i  | c   g   i   i  |
        //  3 | d   c   c   h   i  | d   h   j   i  |
        //  4 | e   d   d   i   j  | e   i       j  |
        //  5 | f   e   e   i      | f   j          |
        //  6 | g   f   f   j      | g              |
        //  7 | h   g   g          | h              |
        //  8 | i   h   h          | i              |
        // 10 | j   i   i          | j              |
        // 11 |     j   i          |                |
        // 12 |         j          |                |

        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 10,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 4,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 2,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn interrupted_left_actions_2() {
        // # | BF  L1  L2  R1  R2 | BF  M1  M2 |
        // 0 | a   a   a   b   b  | a   b   b  |
        // 1 | b   b   b   c   c  | b   c   c  |
        // 2 | c   b   b   d   f  | c   d   f  |
        // 3 | d   c   c   e   g  | d   e   g  |
        // 4 | e   d   d   f      | e   f      |
        // 5 | f   e   e   f      | f   g      |
        // 6 | g   f   f   g      | g          |
        // 7 |     g   f          |            |
        // 8 |         g          |            |

        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 6,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 2,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn chained_right_drops() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 10,
            run_len: 1,
        }];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 8,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn overlapping_drops() {
        let a = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 3,
            run_len: 5,
        }];
        let b = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 2,
            run_len: 3,
        }];
        let merged_a_b = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 2,
            run_len: 8,
        }];
        let merged_b_a = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 3,
                run_len: 5,
            },
        ];
        compare_merge_result(a, b, merged_a_b);
        compare_merge_result(b, a, merged_b_a);
    }

    #[test]
    fn drop_inside_dup() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 3,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let merged = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 2,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_deletes_dup() {
        // # | BF  L   R  |
        // 0 | a   a   a  |
        // 1 | b   a   b  |
        // 2 |     a      |
        // 3 |     b      |

        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 2,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 2,
        }];
        let merged = &[];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_erasing_multiple_dups() {
        // # | BF  L1  L2  L3  R  | BF M |
        // 0 | a   a   a   a   a  | a  a |
        // 1 | b   b   b   b   e  | b  e |
        // 2 | c   b   b   b      | c    |
        // 3 | d   c   c   c      | d    |
        // 4 | e   d   c   c      | e    |
        // 5 |     e   d   d      |      |
        // 6 |         e   d      |      |
        // 7 |             e      |      |

        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 3,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 5,
                run_len: 1,
            },
        ];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 6,
        }];
        let merged = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 3,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn multiple_drops_reduce_dup() {
        // # | BF  L   R1 R2 | BF M |
        // 0 | a   a   a  a  | a  a |
        // 1 | b   a   a  a  | b  a |
        // 2 |     a   a  b  |    b |
        // 3 |     a   b     |      |
        // 4 |     b         |      |

        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 3,
        }];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 1,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drop_doesnt_delete_insert() {
        // # | BF  L   R   | BF  M1  M2 |
        // 0 | a   x   x   | a   x   x  |
        // 1 | b   x   b   | b   a   b  |
        // 2 |     a       |     b      |
        // 3 |     b       |            |

        let left = &[FieldAction {
            kind: FAK::InsertZst(FieldValueRepr::Undefined),
            field_idx: 0,
            run_len: 2,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 2,
        }];
        let merged = &[
            FieldAction {
                kind: FAK::InsertZst(FieldValueRepr::Undefined),
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn drops_are_combined() {
        // # | BF  L1  L2  L3  R  | BF  M |
        // 0 | a   c   c   c      | a     |
        // 1 | b   d   e   e      | b     |
        // 2 | c   e   f   g      | c     |
        // 3 | d   f   g          | d     |
        // 4 | e   g              | e     |
        // 5 | f                  | f     |
        // 5 | g                  | g     |

        let left = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 2,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 3,
        }];
        let merged = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 7,
        }];
        compare_merge_result(left, right, merged);
    }
}
