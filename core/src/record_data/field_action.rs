use std::{
    collections::VecDeque,
    ops::{Index, IndexMut},
};

use super::field_value_repr::RunLength;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum FieldActionKind {
    #[default]
    Dup,
    Drop,
    InsertGroupSeparator,
}

/// In lists of `FieldAction`s, the indices assume that all previous actions
/// were applied.
///
/// Consecutive field actions of the same kind and with the same index have
/// the same semantics as a single action with the summed run length.
///
/// Field actions with a run length greater than `RunLength::MAX` can
/// therefore be represented by multiple, consecutive field actions on the
/// same index. Typically, all `FieldAction`s in such a chain but the last one
/// will have the maximum possible run length.
///
/// `FieldAction`s Lists shall maintain the following invariants:
///
/// - Each index in a list must be at least as large as the previous.
///
/// - Indices may **not** refer to fields that were generated by previous
///   actions.
///
/// - `Insert`s shall not refer to indexes that were `Dup`ed on before.
///
///   E.g.: `[Dup{idx: 0, rl: 3}, Drop{idx: 2, rl: 3}]` is illegal.
///   It should be expressed as `[Dup{idx: 0, rl: 1}, Drop{idx: 2, rl: 1}]`.
///
///   Similarily, two consecutive `Dup`s must either refer to the same
///   starting index, or the second one must point *after* the last index
///   occupied by results of the first `Dup`.
///
/// Violating these invariants may lead to unexpected behavior, panics or
/// infinite loops. Memory safety shall be maintained though.
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct FieldAction {
    pub kind: FieldActionKind,
    pub field_idx: usize,
    pub run_len: RunLength,
}

impl FieldAction {
    pub fn new(
        kind: FieldActionKind,
        field_idx: usize,
        run_len: RunLength,
    ) -> Self {
        Self {
            kind,
            field_idx,
            run_len,
        }
    }
}

pub trait ActionContainer:
    Index<usize, Output = FieldAction> + IndexMut<usize, Output = FieldAction>
{
    fn get(&self, index: usize) -> Option<&FieldAction>;
    fn last_mut(&mut self) -> Option<&mut FieldAction>;
    fn push(&mut self, v: FieldAction);
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

impl ActionContainer for Vec<FieldAction> {
    fn get(&self, index: usize) -> Option<&FieldAction> {
        <[FieldAction]>::get(self, index)
    }
    fn last_mut(&mut self) -> Option<&mut FieldAction> {
        <[FieldAction]>::last_mut(self)
    }
    fn push(&mut self, v: FieldAction) {
        <Vec<_>>::push(self, v)
    }
    fn len(&self) -> usize {
        <[FieldAction]>::len(self)
    }
}
impl ActionContainer for VecDeque<FieldAction> {
    fn get(&self, index: usize) -> Option<&FieldAction> {
        <VecDeque<_>>::get(self, index)
    }
    fn last_mut(&mut self) -> Option<&mut FieldAction> {
        self.back_mut()
    }
    fn push(&mut self, v: FieldAction) {
        <VecDeque<_>>::push_back(self, v)
    }
    fn len(&self) -> usize {
        <VecDeque<_>>::len(self)
    }
}

fn push_merged_action<T: ActionContainer>(
    target: &mut T,
    first_insert: &mut bool,
    kind: FieldActionKind,
    field_idx: usize,
    mut run_len: usize,
) {
    if *first_insert {
        if run_len == 0 {
            return;
        }
        *first_insert = false;
    } else {
        let prev = target.last_mut().unwrap();
        if prev.field_idx == field_idx && prev.kind == kind {
            let space_rem =
                (RunLength::MAX as usize - prev.run_len as usize).min(run_len);
            prev.run_len += space_rem as RunLength;
            run_len -= space_rem;
        }
    }
    let mut action = FieldAction {
        kind,
        field_idx,
        run_len: 0,
    };
    while run_len > RunLength::MAX as usize {
        action.run_len = RunLength::MAX;
        target.push(action);
        run_len -= RunLength::MAX as usize;
    }
    if run_len > 0 {
        action.run_len = run_len as RunLength;
        target.push(action);
    }
}

pub fn merge_action_lists<
    'a,
    L: IntoIterator<Item = &'a FieldAction>,
    R: IntoIterator<Item = &'a FieldAction>,
    T: ActionContainer,
>(
    left: L,
    right: R,
    target: &mut T,
) {
    let mut left = left.into_iter().peekable();
    let mut right = right.into_iter().peekable();
    let mut first_insert = true;

    let mut next_action_field_idx_left;
    let mut next_action_field_idx_right;
    let mut field_pos_offset_left = 0isize;
    let mut outstanding_drops_right = 0usize;
    while let Some(action_left) = left.peek() {
        if let Some(action_right) = right.peek() {
            next_action_field_idx_right =
                action_right.field_idx + outstanding_drops_right;
        } else {
            next_action_field_idx_right = usize::MAX;
        }
        next_action_field_idx_left =
            (action_left.field_idx as isize + field_pos_offset_left) as usize;
        if next_action_field_idx_left <= next_action_field_idx_right {
            let action_left = *action_left;
            left.next();
            let field_idx = (action_left.field_idx as isize
                + field_pos_offset_left) as usize;
            let mut run_len = action_left.run_len as usize;
            let mut kind = action_left.kind;

            match action_left.kind {
                FieldActionKind::InsertGroupSeparator => todo!("FAK"),
                FieldActionKind::Dup => {
                    let space_to_next = left
                        .peek()
                        .map(|a| a.field_idx - action_left.field_idx)
                        .unwrap_or(usize::MAX);
                    if outstanding_drops_right >= run_len {
                        kind = FieldActionKind::Drop;
                        outstanding_drops_right -= run_len;
                        run_len = outstanding_drops_right.min(space_to_next);
                        outstanding_drops_right -= run_len;
                        field_pos_offset_left -= run_len as isize;
                    } else {
                        run_len -= outstanding_drops_right;
                        outstanding_drops_right = 0;
                    }
                }
                FieldActionKind::Drop => {
                    outstanding_drops_right += run_len;
                    run_len = outstanding_drops_right;
                    outstanding_drops_right -= run_len;
                }
            }
            push_merged_action(
                target,
                &mut first_insert,
                kind,
                field_idx,
                run_len,
            );
        } else {
            debug_assert!(outstanding_drops_right == 0);
            let action_right = right.next().unwrap();
            let field_idx = action_right.field_idx;
            let mut run_len = action_right.run_len as usize;

            match action_right.kind {
                FieldActionKind::InsertGroupSeparator => todo!("FAK"),
                FieldActionKind::Dup => {
                    field_pos_offset_left += run_len as isize;
                }
                FieldActionKind::Drop => {
                    let gap_to_start_left = next_action_field_idx_left
                        - next_action_field_idx_right;
                    if gap_to_start_left < run_len {
                        outstanding_drops_right += run_len - gap_to_start_left;
                        run_len = gap_to_start_left;
                    }
                    field_pos_offset_left -= run_len as isize;
                }
            }
            push_merged_action(
                target,
                &mut first_insert,
                action_right.kind,
                field_idx,
                run_len,
            );
        }
    }
    for action in right {
        push_merged_action(
            target,
            &mut first_insert,
            action.kind,
            action.field_idx,
            action.run_len as usize,
        );
    }
}

#[cfg(test)]
mod test {
    use super::FieldActionKind;

    use super::FieldAction;
    use FieldActionKind as FAK;

    fn compare_merge_result(
        left: &[FieldAction],
        right: &[FieldAction],
        out: &[FieldAction],
    ) {
        let mut output = Vec::new();
        super::merge_action_lists(left, right, &mut output);
        assert_eq!(output.as_slice(), out);
    }
    #[test]
    fn uncontested_drops_survive_merge() {
        let drops = &[
            FieldAction::new(FAK::Drop, 0, 2),
            FieldAction::new(FAK::Drop, 1, 9),
            FieldAction::new(FAK::Drop, 2, 7),
        ];
        compare_merge_result(drops, &[], drops);
        compare_merge_result(&[], drops, drops);
    }

    #[test]
    fn actions_are_merged() {
        for kind in [FAK::Dup, FAK::Drop] {
            let unmerged = &[
                FieldAction {
                    kind,
                    field_idx: 0,
                    run_len: 1,
                },
                FieldAction {
                    kind,
                    field_idx: 0,
                    run_len: 1,
                },
            ];
            let blank = &[];
            let merged = &[FieldAction {
                kind,
                field_idx: 0,
                run_len: 2,
            }];
            compare_merge_result(unmerged, blank, merged);
            compare_merge_result(blank, unmerged, merged);
        }
    }
    #[test]
    fn left_field_indices_are_adjusted() {
        let left = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 6,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn encompassed_dups_are_deleted() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 1,
            run_len: 1,
        }];
        let right = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 5,
        }];
        let merged = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 0,
            run_len: 4,
        }];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn interrupted_left_actions() {
        let left = &[
            FieldAction {
                kind: FAK::Dup,
                field_idx: 1,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 10,
                run_len: 1,
            },
        ];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 5,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 4,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 3,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn chained_right_drops() {
        let left = &[FieldAction {
            kind: FAK::Dup,
            field_idx: 10,
            run_len: 1,
        }];
        let right = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
        ];
        let merged = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 0,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 1,
            },
            FieldAction {
                kind: FAK::Dup,
                field_idx: 8,
                run_len: 1,
            },
        ];
        compare_merge_result(left, right, merged);
    }

    #[test]
    fn overlapping_drops() {
        let a = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 3,
            run_len: 5,
        }];
        let b = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 2,
            run_len: 3,
        }];
        let merged_a_b = &[FieldAction {
            kind: FAK::Drop,
            field_idx: 2,
            run_len: 8,
        }];
        let merged_b_a = &[
            FieldAction {
                kind: FAK::Drop,
                field_idx: 2,
                run_len: 3,
            },
            FieldAction {
                kind: FAK::Drop,
                field_idx: 3,
                run_len: 5,
            },
        ];
        compare_merge_result(a, b, merged_a_b);
        compare_merge_result(b, a, merged_b_a);
    }
}
