types - A summary of the data types used in scr

Overview:
    str         Text
    bytes       Raw bytes
    int         An integer / whole number
    null        The infamous null (JS, Java, ...), NULL (SQL), None (Python)
    undefined   An uninitialized value, visible only through programmer errors
    html        (Part of) an HTML document
    error       Command output in case of an error, contains an error message

str:
    Semantically, this represents a (potentially empty) sequence of unicode
    characters. Internally, it is always represented as UTF-8.
    When operators like `join`, `format` or `regex` have to deal with a mix
    of the <bytes> and <str> types, they will default to outputting <bytes>,
    where the <str> portions are encoded as UTF-8 byte sequences.
    Conversely, values of type <bytes> are never implicitly converted to <str>,
    even if they are valid UTF-8. Explicit conversion can be done using the
    `decode` or `str` operators.

bytes:
    A sequence of raw bytes (can be length zero).
    Operators that consume input from the outside world like `file` or `stdin`
    produce values of this type.
    Values of type <str> can be converted to bytes using the `encode` or `bytes`
    operators.

int:
    Currently, integer values have to be between (inclusive) -2^63 and 2^63 - 1,
    but support for larger numbers is planned.
    Many operators like `print` or `join` will implicitly convert this
    type to <str> (or even <bytes>) as needed, but never the other way around.
    Operators like `seq` or `count` produce this type.

null:
    Type with a single inhabitant, the `null` value.
    It is used when importing data from other formats that have this value
    like JSON or SQL Databases.
    Operators that are called purely for their sideeffects also produce this
    value. The canonical examples are `print` and `write`.
    If an (IO) error occurs, these operators output an <error> value.
    If everything went fine, they produce null.
    Optional capture groups of the `regex` operator also output this value.

undefined:
    Values of this type occur when explicit output lengths lead to
    uninitialized fields in previous columns, like in this example:
    `tl seqn@foo=2 seqn=3 f={foo:?} join=", " p` outputs "1, 2, undefined".
    Most operators will output an error if they encounter this value.

error:
    Generated by operators if their operation failed.
    Contains a message, and the ID of the operator that caused the error.
    <error> values are infective, meaning that operators that receive them as
    input will forward them along instead of attempting to perform their
    operation. Even for operators that merge multiple inputs,
    like `join` or `format`, this means dropping all previous input
    and just outputting the error value. Notable exceptions are
    `print` and `format={:?}`, which will output the error message.

~str, ~bytes and ~error:
    Internally, typeline handles large values split up into multiple chunks.
    This avoids allocating large buffers e.g. if a file or download is used
    as a single value. This behaviour can be configured
    using the stream buffer threshold (sbt) and stream buffer size (sbs)
    settings.
    The chunking remains mostly transparent to the user, but there are
    ways to observe it, like the format string
    f="{:??}", which prints inline strings as "foo", but streamed
    strings as ~"foo". Streaming is only performed for the variable sized
    types (<str> and <bytes>). If an error occurs while handling the stream,
    a Stream Error <~error> value is produced. Again, this type behaves
    virtually identical to the default error type.
