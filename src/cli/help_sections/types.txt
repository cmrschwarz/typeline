types - A summary of the data types used in scr

Overview:
    str       Text
    bytes     Raw bytes
    int       An integer / whole number
    null      An uninitialized or empty value
    html      (Part of) an HTML document
    success   Command output indicating success
    error     Command output in case of an error, contains an error message

str:
    Semantically, this represents a (potentially empty) sequence of unicode
    characters. Internally, it is always represented as UTF-8.
    When operators like `join`, `format` or `regex` have to deal with a mix
    of the <bytes> and <str> types, they will default to outputting <bytes>,
    where the <str> portions are encoded as UTF-8 byte sequences.
    Conversely, values of type <bytes> are never implicitly converted to <str>,
    even if they are valid UTF-8. Explicit conversion can be done using the
    `decode` or `str` operators.

bytes:
    A sequence of raw bytes (can be length zero).
    Operators that consume input from the outside world like `file` or `stdin`
    produce values of this type.
    Values of type <str> can be converted to bytes using the `encode` or `bytes`
    operators.

int:
    Currently, integer values have to be between (inclusive) -2^63 and 2^63 - 1,
    but support for larger numbers is planned.
    Many operators like `print` or `join` will implicitly convert this
    type to <str> (or even <bytes>) as needed, but never the other way around.
    Operators like `seq` or `count` produce this type.

null:
    Type with a single inhabitant, the `null` value.
    It is used when importing data from other formats that have this value
    like JSON or SQL Databases. Optional capture groups of the `regex` operator
    also output this value.

    The value also occurs when explicit output lengths cause lead to
    uninitialized fields in previous columns, like in this example:
    `scr int1@foo=42 seq=3 f={foo:?} join=, p` outputs 42,null,null

success:
    Typically produced by operators that are called purely for
    their sideeffects. The canonical examples are `print` and `write`.
    If an (IO) error occurs, these operators output an <error> value.
    If everything went fine, they produce <success>.

error:
    Generated by operators if their operation failed.
    Contains a message, and the ID of the operator that caused the error.
    <error> values are infective, meaning that operators that receive them as
    input will forward them along instead of attempting to perform their
    operation. Even for operators that merge multiple inputs,
    like `join` or `format`, this means dropping all previous input
    and just outputting the error value. Notable exceptions are
    `print` and `format={:?}`, which will output the error message.

~str, ~bytes and ~error:
    Internally, scr handles large values split up into multiple chunks.
    This avoids allocating large buffers e.g. if a file or download is used
    as a single value. This behaviour can be configured
    using the stream buffer threshold (sbt) and stream buffer size (sbs)
    settings.
    The chunking remains mostly transparent to the user, but there are
    ways to observe it, like the format string
    f="{:??}", which prints inline strings as "foo", but streamed
    strings as ~"foo". Streaming is only performed for the variable sized
    types (<str> and <bytes>). If an error occurs while handling the stream,
    a Stream Error <~error> value is produced. Again, this type behaves
    virtually identical to the default error type.
